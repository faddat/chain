// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lumnetwork/chain/millions/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types1 "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "github.com/cosmos/gogoproto/types"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgUpdateParams struct {
	MinDepositAmount        *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=min_deposit_amount,json=minDepositAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"min_deposit_amount,omitempty"`
	MaxPrizeStrategyBatches *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=max_prize_strategy_batches,json=maxPrizeStrategyBatches,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_prize_strategy_batches,omitempty"`
	MaxPrizeBatchQuantity   *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=max_prize_batch_quantity,json=maxPrizeBatchQuantity,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_prize_batch_quantity,omitempty"`
	MinDrawScheduleDelta    *time.Duration                          `protobuf:"bytes,4,opt,name=min_draw_schedule_delta,json=minDrawScheduleDelta,proto3,stdduration" json:"min_draw_schedule_delta,omitempty"`
	MaxDrawScheduleDelta    *time.Duration                          `protobuf:"bytes,5,opt,name=max_draw_schedule_delta,json=maxDrawScheduleDelta,proto3,stdduration" json:"max_draw_schedule_delta,omitempty"`
	PrizeExpirationDelta    *time.Duration                          `protobuf:"bytes,6,opt,name=prize_expiration_delta,json=prizeExpirationDelta,proto3,stdduration" json:"prize_expiration_delta,omitempty"`
	FeesStakers             *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=fees_stakers,json=feesStakers,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"fees_stakers,omitempty"`
	MinDepositDrawDelta     *time.Duration                          `protobuf:"bytes,8,opt,name=min_deposit_draw_delta,json=minDepositDrawDelta,proto3,stdduration" json:"min_deposit_draw_delta,omitempty"`
	UpdaterAddress          string                                  `protobuf:"bytes,9,opt,name=updater_address,json=updaterAddress,proto3" json:"updater_address,omitempty"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{0}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetMinDrawScheduleDelta() *time.Duration {
	if m != nil {
		return m.MinDrawScheduleDelta
	}
	return nil
}

func (m *MsgUpdateParams) GetMaxDrawScheduleDelta() *time.Duration {
	if m != nil {
		return m.MaxDrawScheduleDelta
	}
	return nil
}

func (m *MsgUpdateParams) GetPrizeExpirationDelta() *time.Duration {
	if m != nil {
		return m.PrizeExpirationDelta
	}
	return nil
}

func (m *MsgUpdateParams) GetMinDepositDrawDelta() *time.Duration {
	if m != nil {
		return m.MinDepositDrawDelta
	}
	return nil
}

func (m *MsgUpdateParams) GetUpdaterAddress() string {
	if m != nil {
		return m.UpdaterAddress
	}
	return ""
}

type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{1}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

type MsgRegisterPool struct {
	ChainId             string                                 `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Denom               string                                 `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	NativeDenom         string                                 `protobuf:"bytes,3,opt,name=native_denom,json=nativeDenom,proto3" json:"native_denom,omitempty"`
	ConnectionId        string                                 `protobuf:"bytes,4,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	Validators          []string                               `protobuf:"bytes,5,rep,name=validators,proto3" json:"validators,omitempty"`
	MinDepositAmount    github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,6,opt,name=min_deposit_amount,json=minDepositAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"min_deposit_amount"`
	DrawSchedule        DrawSchedule                           `protobuf:"bytes,7,opt,name=draw_schedule,json=drawSchedule,proto3" json:"draw_schedule"`
	PrizeStrategy       PrizeStrategy                          `protobuf:"bytes,8,opt,name=prize_strategy,json=prizeStrategy,proto3" json:"prize_strategy"`
	Bech32PrefixAccAddr string                                 `protobuf:"bytes,9,opt,name=bech32_prefix_acc_addr,json=bech32PrefixAccAddr,proto3" json:"bech32_prefix_acc_addr,omitempty"`
	Bech32PrefixValAddr string                                 `protobuf:"bytes,10,opt,name=bech32_prefix_val_addr,json=bech32PrefixValAddr,proto3" json:"bech32_prefix_val_addr,omitempty"`
	CreatorAddress      string                                 `protobuf:"bytes,11,opt,name=creator_address,json=creatorAddress,proto3" json:"creator_address,omitempty"`
}

func (m *MsgRegisterPool) Reset()         { *m = MsgRegisterPool{} }
func (m *MsgRegisterPool) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterPool) ProtoMessage()    {}
func (*MsgRegisterPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{2}
}
func (m *MsgRegisterPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterPool.Merge(m, src)
}
func (m *MsgRegisterPool) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterPool) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterPool.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterPool proto.InternalMessageInfo

func (m *MsgRegisterPool) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *MsgRegisterPool) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgRegisterPool) GetNativeDenom() string {
	if m != nil {
		return m.NativeDenom
	}
	return ""
}

func (m *MsgRegisterPool) GetConnectionId() string {
	if m != nil {
		return m.ConnectionId
	}
	return ""
}

func (m *MsgRegisterPool) GetValidators() []string {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (m *MsgRegisterPool) GetDrawSchedule() DrawSchedule {
	if m != nil {
		return m.DrawSchedule
	}
	return DrawSchedule{}
}

func (m *MsgRegisterPool) GetPrizeStrategy() PrizeStrategy {
	if m != nil {
		return m.PrizeStrategy
	}
	return PrizeStrategy{}
}

func (m *MsgRegisterPool) GetBech32PrefixAccAddr() string {
	if m != nil {
		return m.Bech32PrefixAccAddr
	}
	return ""
}

func (m *MsgRegisterPool) GetBech32PrefixValAddr() string {
	if m != nil {
		return m.Bech32PrefixValAddr
	}
	return ""
}

func (m *MsgRegisterPool) GetCreatorAddress() string {
	if m != nil {
		return m.CreatorAddress
	}
	return ""
}

type MsgRegisterPoolResponse struct {
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
}

func (m *MsgRegisterPoolResponse) Reset()         { *m = MsgRegisterPoolResponse{} }
func (m *MsgRegisterPoolResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterPoolResponse) ProtoMessage()    {}
func (*MsgRegisterPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{3}
}
func (m *MsgRegisterPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterPoolResponse.Merge(m, src)
}
func (m *MsgRegisterPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterPoolResponse proto.InternalMessageInfo

func (m *MsgRegisterPoolResponse) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

type MsgUpdatePool struct {
	PoolId           uint64                                  `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	Validators       []string                                `protobuf:"bytes,2,rep,name=validators,proto3" json:"validators,omitempty"`
	MinDepositAmount *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=min_deposit_amount,json=minDepositAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"min_deposit_amount,omitempty"`
	DrawSchedule     *DrawSchedule                           `protobuf:"bytes,4,opt,name=draw_schedule,json=drawSchedule,proto3" json:"draw_schedule,omitempty"`
	PrizeStrategy    *PrizeStrategy                          `protobuf:"bytes,5,opt,name=prize_strategy,json=prizeStrategy,proto3" json:"prize_strategy,omitempty"`
	UpdaterAddress   string                                  `protobuf:"bytes,6,opt,name=updater_address,json=updaterAddress,proto3" json:"updater_address,omitempty"`
}

func (m *MsgUpdatePool) Reset()         { *m = MsgUpdatePool{} }
func (m *MsgUpdatePool) String() string { return proto.CompactTextString(m) }
func (*MsgUpdatePool) ProtoMessage()    {}
func (*MsgUpdatePool) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{4}
}
func (m *MsgUpdatePool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdatePool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdatePool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdatePool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdatePool.Merge(m, src)
}
func (m *MsgUpdatePool) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdatePool) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdatePool.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdatePool proto.InternalMessageInfo

func (m *MsgUpdatePool) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *MsgUpdatePool) GetValidators() []string {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (m *MsgUpdatePool) GetDrawSchedule() *DrawSchedule {
	if m != nil {
		return m.DrawSchedule
	}
	return nil
}

func (m *MsgUpdatePool) GetPrizeStrategy() *PrizeStrategy {
	if m != nil {
		return m.PrizeStrategy
	}
	return nil
}

func (m *MsgUpdatePool) GetUpdaterAddress() string {
	if m != nil {
		return m.UpdaterAddress
	}
	return ""
}

type MsgUpdatePoolResponse struct {
}

func (m *MsgUpdatePoolResponse) Reset()         { *m = MsgUpdatePoolResponse{} }
func (m *MsgUpdatePoolResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdatePoolResponse) ProtoMessage()    {}
func (*MsgUpdatePoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{5}
}
func (m *MsgUpdatePoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdatePoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdatePoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdatePoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdatePoolResponse.Merge(m, src)
}
func (m *MsgUpdatePoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdatePoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdatePoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdatePoolResponse proto.InternalMessageInfo

type MsgDeposit struct {
	PoolId           uint64      `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	Amount           types1.Coin `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
	DepositorAddress string      `protobuf:"bytes,3,opt,name=depositor_address,json=depositorAddress,proto3" json:"depositor_address,omitempty"`
	WinnerAddress    string      `protobuf:"bytes,4,opt,name=winner_address,json=winnerAddress,proto3" json:"winner_address,omitempty"`
	IsSponsor        bool        `protobuf:"varint,5,opt,name=is_sponsor,json=isSponsor,proto3" json:"is_sponsor,omitempty"`
}

func (m *MsgDeposit) Reset()         { *m = MsgDeposit{} }
func (m *MsgDeposit) String() string { return proto.CompactTextString(m) }
func (*MsgDeposit) ProtoMessage()    {}
func (*MsgDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{6}
}
func (m *MsgDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeposit.Merge(m, src)
}
func (m *MsgDeposit) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeposit proto.InternalMessageInfo

func (m *MsgDeposit) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *MsgDeposit) GetAmount() types1.Coin {
	if m != nil {
		return m.Amount
	}
	return types1.Coin{}
}

func (m *MsgDeposit) GetDepositorAddress() string {
	if m != nil {
		return m.DepositorAddress
	}
	return ""
}

func (m *MsgDeposit) GetWinnerAddress() string {
	if m != nil {
		return m.WinnerAddress
	}
	return ""
}

func (m *MsgDeposit) GetIsSponsor() bool {
	if m != nil {
		return m.IsSponsor
	}
	return false
}

type MsgDepositResponse struct {
	DepositId uint64 `protobuf:"varint,1,opt,name=deposit_id,json=depositId,proto3" json:"deposit_id,omitempty"`
}

func (m *MsgDepositResponse) Reset()         { *m = MsgDepositResponse{} }
func (m *MsgDepositResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositResponse) ProtoMessage()    {}
func (*MsgDepositResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{7}
}
func (m *MsgDepositResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositResponse.Merge(m, src)
}
func (m *MsgDepositResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositResponse proto.InternalMessageInfo

func (m *MsgDepositResponse) GetDepositId() uint64 {
	if m != nil {
		return m.DepositId
	}
	return 0
}

type MsgDepositRetry struct {
	PoolId           uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	DepositId        uint64 `protobuf:"varint,2,opt,name=deposit_id,json=depositId,proto3" json:"deposit_id,omitempty"`
	DepositorAddress string `protobuf:"bytes,3,opt,name=depositor_address,json=depositorAddress,proto3" json:"depositor_address,omitempty"`
}

func (m *MsgDepositRetry) Reset()         { *m = MsgDepositRetry{} }
func (m *MsgDepositRetry) String() string { return proto.CompactTextString(m) }
func (*MsgDepositRetry) ProtoMessage()    {}
func (*MsgDepositRetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{8}
}
func (m *MsgDepositRetry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositRetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositRetry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositRetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositRetry.Merge(m, src)
}
func (m *MsgDepositRetry) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositRetry) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositRetry.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositRetry proto.InternalMessageInfo

func (m *MsgDepositRetry) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *MsgDepositRetry) GetDepositId() uint64 {
	if m != nil {
		return m.DepositId
	}
	return 0
}

func (m *MsgDepositRetry) GetDepositorAddress() string {
	if m != nil {
		return m.DepositorAddress
	}
	return ""
}

type MsgDepositRetryResponse struct {
}

func (m *MsgDepositRetryResponse) Reset()         { *m = MsgDepositRetryResponse{} }
func (m *MsgDepositRetryResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDepositRetryResponse) ProtoMessage()    {}
func (*MsgDepositRetryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{9}
}
func (m *MsgDepositRetryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDepositRetryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDepositRetryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDepositRetryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDepositRetryResponse.Merge(m, src)
}
func (m *MsgDepositRetryResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDepositRetryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDepositRetryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDepositRetryResponse proto.InternalMessageInfo

type MsgClaimPrize struct {
	PoolId        uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	DrawId        uint64 `protobuf:"varint,2,opt,name=draw_id,json=drawId,proto3" json:"draw_id,omitempty"`
	PrizeId       uint64 `protobuf:"varint,3,opt,name=prize_id,json=prizeId,proto3" json:"prize_id,omitempty"`
	WinnerAddress string `protobuf:"bytes,4,opt,name=winner_address,json=winnerAddress,proto3" json:"winner_address,omitempty"`
}

func (m *MsgClaimPrize) Reset()         { *m = MsgClaimPrize{} }
func (m *MsgClaimPrize) String() string { return proto.CompactTextString(m) }
func (*MsgClaimPrize) ProtoMessage()    {}
func (*MsgClaimPrize) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{10}
}
func (m *MsgClaimPrize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimPrize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimPrize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimPrize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimPrize.Merge(m, src)
}
func (m *MsgClaimPrize) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimPrize) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimPrize.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimPrize proto.InternalMessageInfo

func (m *MsgClaimPrize) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *MsgClaimPrize) GetDrawId() uint64 {
	if m != nil {
		return m.DrawId
	}
	return 0
}

func (m *MsgClaimPrize) GetPrizeId() uint64 {
	if m != nil {
		return m.PrizeId
	}
	return 0
}

func (m *MsgClaimPrize) GetWinnerAddress() string {
	if m != nil {
		return m.WinnerAddress
	}
	return ""
}

type MsgClaimPrizeResponse struct {
}

func (m *MsgClaimPrizeResponse) Reset()         { *m = MsgClaimPrizeResponse{} }
func (m *MsgClaimPrizeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimPrizeResponse) ProtoMessage()    {}
func (*MsgClaimPrizeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{11}
}
func (m *MsgClaimPrizeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimPrizeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimPrizeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimPrizeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimPrizeResponse.Merge(m, src)
}
func (m *MsgClaimPrizeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimPrizeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimPrizeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimPrizeResponse proto.InternalMessageInfo

type MsgWithdrawDeposit struct {
	PoolId           uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	DepositId        uint64 `protobuf:"varint,2,opt,name=deposit_id,json=depositId,proto3" json:"deposit_id,omitempty"`
	DepositorAddress string `protobuf:"bytes,3,opt,name=depositor_address,json=depositorAddress,proto3" json:"depositor_address,omitempty"`
	ToAddress        string `protobuf:"bytes,4,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty"`
}

func (m *MsgWithdrawDeposit) Reset()         { *m = MsgWithdrawDeposit{} }
func (m *MsgWithdrawDeposit) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawDeposit) ProtoMessage()    {}
func (*MsgWithdrawDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{12}
}
func (m *MsgWithdrawDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawDeposit.Merge(m, src)
}
func (m *MsgWithdrawDeposit) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawDeposit proto.InternalMessageInfo

func (m *MsgWithdrawDeposit) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *MsgWithdrawDeposit) GetDepositId() uint64 {
	if m != nil {
		return m.DepositId
	}
	return 0
}

func (m *MsgWithdrawDeposit) GetDepositorAddress() string {
	if m != nil {
		return m.DepositorAddress
	}
	return ""
}

func (m *MsgWithdrawDeposit) GetToAddress() string {
	if m != nil {
		return m.ToAddress
	}
	return ""
}

type MsgWithdrawDepositResponse struct {
	WithdrawalId uint64 `protobuf:"varint,1,opt,name=withdrawal_id,json=withdrawalId,proto3" json:"withdrawal_id,omitempty"`
}

func (m *MsgWithdrawDepositResponse) Reset()         { *m = MsgWithdrawDepositResponse{} }
func (m *MsgWithdrawDepositResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawDepositResponse) ProtoMessage()    {}
func (*MsgWithdrawDepositResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{13}
}
func (m *MsgWithdrawDepositResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawDepositResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawDepositResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawDepositResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawDepositResponse.Merge(m, src)
}
func (m *MsgWithdrawDepositResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawDepositResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawDepositResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawDepositResponse proto.InternalMessageInfo

func (m *MsgWithdrawDepositResponse) GetWithdrawalId() uint64 {
	if m != nil {
		return m.WithdrawalId
	}
	return 0
}

type MsgWithdrawDepositRetry struct {
	PoolId           uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	WithdrawalId     uint64 `protobuf:"varint,2,opt,name=withdrawal_id,json=withdrawalId,proto3" json:"withdrawal_id,omitempty"`
	DepositorAddress string `protobuf:"bytes,3,opt,name=depositor_address,json=depositorAddress,proto3" json:"depositor_address,omitempty"`
}

func (m *MsgWithdrawDepositRetry) Reset()         { *m = MsgWithdrawDepositRetry{} }
func (m *MsgWithdrawDepositRetry) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawDepositRetry) ProtoMessage()    {}
func (*MsgWithdrawDepositRetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{14}
}
func (m *MsgWithdrawDepositRetry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawDepositRetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawDepositRetry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawDepositRetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawDepositRetry.Merge(m, src)
}
func (m *MsgWithdrawDepositRetry) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawDepositRetry) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawDepositRetry.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawDepositRetry proto.InternalMessageInfo

func (m *MsgWithdrawDepositRetry) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *MsgWithdrawDepositRetry) GetWithdrawalId() uint64 {
	if m != nil {
		return m.WithdrawalId
	}
	return 0
}

func (m *MsgWithdrawDepositRetry) GetDepositorAddress() string {
	if m != nil {
		return m.DepositorAddress
	}
	return ""
}

type MsgWithdrawDepositRetryResponse struct {
}

func (m *MsgWithdrawDepositRetryResponse) Reset()         { *m = MsgWithdrawDepositRetryResponse{} }
func (m *MsgWithdrawDepositRetryResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawDepositRetryResponse) ProtoMessage()    {}
func (*MsgWithdrawDepositRetryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{15}
}
func (m *MsgWithdrawDepositRetryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawDepositRetryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawDepositRetryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawDepositRetryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawDepositRetryResponse.Merge(m, src)
}
func (m *MsgWithdrawDepositRetryResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawDepositRetryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawDepositRetryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawDepositRetryResponse proto.InternalMessageInfo

type MsgDrawRetry struct {
	PoolId           uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	DrawId           uint64 `protobuf:"varint,2,opt,name=draw_id,json=drawId,proto3" json:"draw_id,omitempty"`
	DrawRetryAddress string `protobuf:"bytes,3,opt,name=draw_retry_address,json=drawRetryAddress,proto3" json:"draw_retry_address,omitempty"`
}

func (m *MsgDrawRetry) Reset()         { *m = MsgDrawRetry{} }
func (m *MsgDrawRetry) String() string { return proto.CompactTextString(m) }
func (*MsgDrawRetry) ProtoMessage()    {}
func (*MsgDrawRetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{16}
}
func (m *MsgDrawRetry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDrawRetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDrawRetry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDrawRetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDrawRetry.Merge(m, src)
}
func (m *MsgDrawRetry) XXX_Size() int {
	return m.Size()
}
func (m *MsgDrawRetry) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDrawRetry.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDrawRetry proto.InternalMessageInfo

func (m *MsgDrawRetry) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *MsgDrawRetry) GetDrawId() uint64 {
	if m != nil {
		return m.DrawId
	}
	return 0
}

func (m *MsgDrawRetry) GetDrawRetryAddress() string {
	if m != nil {
		return m.DrawRetryAddress
	}
	return ""
}

type MsgDrawRetryResponse struct {
}

func (m *MsgDrawRetryResponse) Reset()         { *m = MsgDrawRetryResponse{} }
func (m *MsgDrawRetryResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDrawRetryResponse) ProtoMessage()    {}
func (*MsgDrawRetryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{17}
}
func (m *MsgDrawRetryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDrawRetryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDrawRetryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDrawRetryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDrawRetryResponse.Merge(m, src)
}
func (m *MsgDrawRetryResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDrawRetryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDrawRetryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDrawRetryResponse proto.InternalMessageInfo

type MsgRestoreInterchainAccounts struct {
	PoolId          uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	RestorerAddress string `protobuf:"bytes,2,opt,name=restorer_address,json=restorerAddress,proto3" json:"restorer_address,omitempty"`
}

func (m *MsgRestoreInterchainAccounts) Reset()         { *m = MsgRestoreInterchainAccounts{} }
func (m *MsgRestoreInterchainAccounts) String() string { return proto.CompactTextString(m) }
func (*MsgRestoreInterchainAccounts) ProtoMessage()    {}
func (*MsgRestoreInterchainAccounts) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{18}
}
func (m *MsgRestoreInterchainAccounts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRestoreInterchainAccounts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRestoreInterchainAccounts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRestoreInterchainAccounts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRestoreInterchainAccounts.Merge(m, src)
}
func (m *MsgRestoreInterchainAccounts) XXX_Size() int {
	return m.Size()
}
func (m *MsgRestoreInterchainAccounts) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRestoreInterchainAccounts.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRestoreInterchainAccounts proto.InternalMessageInfo

func (m *MsgRestoreInterchainAccounts) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *MsgRestoreInterchainAccounts) GetRestorerAddress() string {
	if m != nil {
		return m.RestorerAddress
	}
	return ""
}

type MsgRestoreInterchainAccountsResponse struct {
}

func (m *MsgRestoreInterchainAccountsResponse) Reset()         { *m = MsgRestoreInterchainAccountsResponse{} }
func (m *MsgRestoreInterchainAccountsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRestoreInterchainAccountsResponse) ProtoMessage()    {}
func (*MsgRestoreInterchainAccountsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ad25db6fb1b107f4, []int{19}
}
func (m *MsgRestoreInterchainAccountsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRestoreInterchainAccountsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRestoreInterchainAccountsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRestoreInterchainAccountsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRestoreInterchainAccountsResponse.Merge(m, src)
}
func (m *MsgRestoreInterchainAccountsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRestoreInterchainAccountsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRestoreInterchainAccountsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRestoreInterchainAccountsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgUpdateParams)(nil), "lumnetwork.chain.millions.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "lumnetwork.chain.millions.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgRegisterPool)(nil), "lumnetwork.chain.millions.MsgRegisterPool")
	proto.RegisterType((*MsgRegisterPoolResponse)(nil), "lumnetwork.chain.millions.MsgRegisterPoolResponse")
	proto.RegisterType((*MsgUpdatePool)(nil), "lumnetwork.chain.millions.MsgUpdatePool")
	proto.RegisterType((*MsgUpdatePoolResponse)(nil), "lumnetwork.chain.millions.MsgUpdatePoolResponse")
	proto.RegisterType((*MsgDeposit)(nil), "lumnetwork.chain.millions.MsgDeposit")
	proto.RegisterType((*MsgDepositResponse)(nil), "lumnetwork.chain.millions.MsgDepositResponse")
	proto.RegisterType((*MsgDepositRetry)(nil), "lumnetwork.chain.millions.MsgDepositRetry")
	proto.RegisterType((*MsgDepositRetryResponse)(nil), "lumnetwork.chain.millions.MsgDepositRetryResponse")
	proto.RegisterType((*MsgClaimPrize)(nil), "lumnetwork.chain.millions.MsgClaimPrize")
	proto.RegisterType((*MsgClaimPrizeResponse)(nil), "lumnetwork.chain.millions.MsgClaimPrizeResponse")
	proto.RegisterType((*MsgWithdrawDeposit)(nil), "lumnetwork.chain.millions.MsgWithdrawDeposit")
	proto.RegisterType((*MsgWithdrawDepositResponse)(nil), "lumnetwork.chain.millions.MsgWithdrawDepositResponse")
	proto.RegisterType((*MsgWithdrawDepositRetry)(nil), "lumnetwork.chain.millions.MsgWithdrawDepositRetry")
	proto.RegisterType((*MsgWithdrawDepositRetryResponse)(nil), "lumnetwork.chain.millions.MsgWithdrawDepositRetryResponse")
	proto.RegisterType((*MsgDrawRetry)(nil), "lumnetwork.chain.millions.MsgDrawRetry")
	proto.RegisterType((*MsgDrawRetryResponse)(nil), "lumnetwork.chain.millions.MsgDrawRetryResponse")
	proto.RegisterType((*MsgRestoreInterchainAccounts)(nil), "lumnetwork.chain.millions.MsgRestoreInterchainAccounts")
	proto.RegisterType((*MsgRestoreInterchainAccountsResponse)(nil), "lumnetwork.chain.millions.MsgRestoreInterchainAccountsResponse")
}

func init() {
	proto.RegisterFile("lumnetwork/chain/millions/tx.proto", fileDescriptor_ad25db6fb1b107f4)
}

var fileDescriptor_ad25db6fb1b107f4 = []byte{
	// 1324 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x4f, 0x6f, 0x13, 0x47,
	0x14, 0xcf, 0x3a, 0x8e, 0x13, 0xbf, 0x38, 0x84, 0x2e, 0x21, 0x71, 0xac, 0xe2, 0x80, 0xa1, 0x10,
	0x55, 0xca, 0xba, 0x38, 0xaa, 0x90, 0x7a, 0x41, 0x0e, 0xa1, 0x95, 0x0f, 0x48, 0x61, 0x23, 0xfa,
	0x07, 0x55, 0x5a, 0x8d, 0x77, 0x07, 0x7b, 0x94, 0xdd, 0x1d, 0x77, 0x67, 0x1c, 0x3b, 0x55, 0xaf,
	0xad, 0x7a, 0xe4, 0x52, 0xa9, 0xaa, 0xd4, 0x7e, 0x8a, 0x7e, 0x81, 0xde, 0x38, 0xf4, 0x80, 0x7a,
	0xaa, 0x7a, 0xa0, 0x08, 0xbe, 0x48, 0xb5, 0x33, 0xb3, 0x7f, 0x1c, 0xb3, 0xb1, 0x1d, 0x50, 0x4f,
	0x30, 0x33, 0xef, 0xfd, 0xde, 0x6f, 0xde, 0xfb, 0xbd, 0x37, 0x1b, 0x43, 0xcd, 0xed, 0x7b, 0x3e,
	0xe6, 0x03, 0x1a, 0x1c, 0xd5, 0xed, 0x2e, 0x22, 0x7e, 0xdd, 0x23, 0xae, 0x4b, 0xa8, 0xcf, 0xea,
	0x7c, 0x68, 0xf4, 0x02, 0xca, 0xa9, 0xbe, 0x99, 0xd8, 0x18, 0xc2, 0xc6, 0x88, 0x6c, 0x2a, 0x6b,
	0x1d, 0xda, 0xa1, 0xc2, 0xaa, 0x1e, 0xfe, 0x4f, 0x3a, 0x54, 0xaa, 0x1d, 0x4a, 0x3b, 0x2e, 0xae,
	0x8b, 0x55, 0xbb, 0xff, 0xa4, 0xee, 0xf4, 0x03, 0xc4, 0x09, 0xf5, 0xa3, 0x73, 0x9b, 0x32, 0x8f,
	0xb2, 0x7a, 0x1b, 0x31, 0x5c, 0x3f, 0xbe, 0xdd, 0xc6, 0x1c, 0xdd, 0xae, 0xdb, 0x94, 0x44, 0xe7,
	0x9b, 0xf2, 0xdc, 0x92, 0xc0, 0x72, 0xa1, 0x8e, 0x76, 0xb2, 0xf9, 0x3a, 0x01, 0x1a, 0x58, 0xcc,
	0xee, 0x62, 0xa7, 0xef, 0x62, 0x65, 0x6e, 0x64, 0x9b, 0xf7, 0x02, 0xf2, 0x2d, 0xb6, 0x18, 0x0f,
	0x10, 0xc7, 0x9d, 0x13, 0x69, 0x5f, 0x7b, 0x56, 0x80, 0xd5, 0x07, 0xac, 0xf3, 0xa8, 0xe7, 0x20,
	0x8e, 0x0f, 0x50, 0x80, 0x3c, 0xa6, 0x7f, 0x0d, 0xba, 0x47, 0x7c, 0xcb, 0xc1, 0x3d, 0xca, 0x08,
	0xb7, 0x90, 0x47, 0xfb, 0x3e, 0x2f, 0x6b, 0x57, 0xb5, 0xed, 0xe2, 0x9e, 0xf1, 0xec, 0xc5, 0x96,
	0xf6, 0xcf, 0x8b, 0xad, 0x9b, 0x1d, 0xc2, 0xbb, 0xfd, 0xb6, 0x61, 0x53, 0x4f, 0xf1, 0x55, 0xff,
	0xec, 0x30, 0xe7, 0xa8, 0xce, 0x4f, 0x7a, 0x98, 0x19, 0x2d, 0x9f, 0x9b, 0x17, 0x3d, 0xe2, 0xef,
	0x4b, 0xa0, 0xa6, 0xc0, 0xd1, 0x8f, 0xa0, 0xe2, 0xa1, 0xa1, 0x35, 0xca, 0xc6, 0x6a, 0x23, 0x6e,
	0x77, 0x31, 0x2b, 0xe7, 0xce, 0x15, 0x65, 0xc3, 0x43, 0xc3, 0x83, 0x10, 0xf0, 0x50, 0xe1, 0xed,
	0x49, 0x38, 0xbd, 0x03, 0xe5, 0x24, 0x98, 0x88, 0x61, 0x7d, 0xd3, 0x47, 0x3e, 0x27, 0xfc, 0xa4,
	0x3c, 0x7f, 0xae, 0x50, 0x97, 0xa3, 0x50, 0x22, 0xc4, 0x43, 0x05, 0xa6, 0x3f, 0x86, 0x0d, 0x91,
	0xb3, 0x74, 0x49, 0x2c, 0x07, 0xbb, 0x1c, 0x95, 0xf3, 0x57, 0xb5, 0xed, 0xe5, 0xc6, 0xa6, 0x21,
	0x35, 0x62, 0x44, 0x1a, 0x31, 0xf6, 0x95, 0x46, 0xf6, 0x96, 0x42, 0x0a, 0x3f, 0xff, 0xbb, 0xa5,
	0x99, 0x6b, 0x61, 0xb6, 0x02, 0x34, 0x38, 0x54, 0x08, 0xfb, 0x21, 0x80, 0xc0, 0x46, 0xc3, 0x37,
	0x62, 0x2f, 0xcc, 0x82, 0x8d, 0x86, 0xe3, 0xd8, 0x5f, 0xc1, 0xba, 0x4c, 0x0e, 0x1e, 0xf6, 0x88,
	0xf4, 0x51, 0xd0, 0x85, 0x19, 0xa0, 0x05, 0xc4, 0xfd, 0x18, 0x41, 0x42, 0x3f, 0x84, 0xd2, 0x13,
	0x8c, 0x99, 0xc5, 0x38, 0x3a, 0xc2, 0x01, 0x2b, 0x2f, 0xce, 0x9c, 0xef, 0x7d, 0x6c, 0x9b, 0xcb,
	0x21, 0xc6, 0xa1, 0x84, 0xd0, 0xbf, 0x84, 0xf5, 0xb4, 0x32, 0x45, 0x46, 0x24, 0xdb, 0xa5, 0xe9,
	0xd9, 0x5e, 0x4a, 0x24, 0x19, 0xe6, 0x43, 0x92, 0x6d, 0xc2, 0x6a, 0x5f, 0xf4, 0x40, 0x60, 0x21,
	0xc7, 0x09, 0x30, 0x63, 0xe5, 0xa2, 0xe0, 0x5b, 0xfe, 0xeb, 0xf7, 0x9d, 0x35, 0xd5, 0x91, 0x4d,
	0x79, 0x72, 0xc8, 0x03, 0xe2, 0x77, 0xcc, 0x0b, 0xca, 0x41, 0xed, 0xd6, 0x36, 0x61, 0xe3, 0x54,
	0x27, 0x99, 0x98, 0xf5, 0xa8, 0xcf, 0x70, 0xed, 0x65, 0x5e, 0x74, 0x99, 0x89, 0x3b, 0x84, 0x71,
	0x1c, 0x1c, 0x50, 0xea, 0xea, 0x9b, 0xb0, 0x24, 0x1a, 0xd4, 0x22, 0x8e, 0xec, 0x2d, 0x73, 0x51,
	0xac, 0x5b, 0x8e, 0xbe, 0x06, 0x0b, 0x0e, 0xf6, 0xa9, 0x27, 0xbb, 0xc1, 0x94, 0x0b, 0xfd, 0x1a,
	0x94, 0x7c, 0xc4, 0xc9, 0x71, 0x58, 0xfb, 0xf0, 0x50, 0xe8, 0xd7, 0x5c, 0x96, 0x7b, 0xfb, 0xc2,
	0xe4, 0x3a, 0xac, 0xd8, 0xd4, 0xf7, 0xb1, 0x2d, 0xea, 0x48, 0x1c, 0xa1, 0xbd, 0xa2, 0x59, 0x4a,
	0x36, 0x5b, 0x8e, 0x5e, 0x05, 0x38, 0x46, 0x2e, 0x71, 0x10, 0xa7, 0x01, 0x2b, 0x2f, 0x5c, 0x9d,
	0xdf, 0x2e, 0x9a, 0xa9, 0x9d, 0x8c, 0xf6, 0x2f, 0xc4, 0xd5, 0x9b, 0x7b, 0xab, 0xf6, 0x37, 0x61,
	0x65, 0x44, 0xc8, 0x42, 0x16, 0xcb, 0x8d, 0x5b, 0x46, 0xe6, 0xcc, 0x35, 0xd2, 0xaa, 0xdd, 0xcb,
	0x87, 0x0c, 0xcc, 0x92, 0x93, 0xda, 0xd3, 0x1f, 0xc1, 0x85, 0xd1, 0x71, 0xa2, 0xe4, 0xb0, 0x7d,
	0x06, 0xe8, 0xe8, 0xb8, 0x90, 0xa8, 0x2b, 0xbd, 0xf4, 0xa6, 0xbe, 0x0b, 0xeb, 0x6d, 0x6c, 0x77,
	0x77, 0x1b, 0x56, 0x2f, 0xc0, 0x4f, 0xc8, 0xd0, 0x42, 0xb6, 0x2d, 0xd4, 0x21, 0xa5, 0x61, 0x5e,
	0x92, 0xa7, 0x07, 0xe2, 0xb0, 0x69, 0xdb, 0xa1, 0x10, 0xc6, 0x9d, 0x8e, 0x91, 0x2b, 0x9d, 0x60,
	0xdc, 0xe9, 0x73, 0xe4, 0x0a, 0xa7, 0x26, 0xac, 0xda, 0x01, 0x0e, 0xd3, 0x1f, 0xab, 0x6f, 0x79,
	0x92, 0xfa, 0x94, 0x43, 0xa4, 0xbe, 0x86, 0x50, 0x5f, 0x5a, 0x61, 0x91, 0xfa, 0xf4, 0x0d, 0x58,
	0xec, 0x51, 0xea, 0x46, 0x42, 0xcb, 0x9b, 0x85, 0x70, 0xd9, 0x72, 0x6a, 0xbf, 0xcc, 0xc3, 0x4a,
	0x22, 0xd9, 0x50, 0x94, 0x59, 0xa6, 0xfa, 0x8d, 0x11, 0xd1, 0xe4, 0x42, 0xd1, 0x88, 0xa4, 0x69,
	0x53, 0x48, 0x67, 0xfe, 0x1d, 0xbd, 0x1c, 0x63, 0xd2, 0xc9, 0xcf, 0x2e, 0x1d, 0x6d, 0xa2, 0x74,
	0x16, 0xce, 0x21, 0x1d, 0xed, 0xb4, 0x74, 0xde, 0x30, 0x4e, 0x0a, 0x33, 0x8e, 0x93, 0x0d, 0xb8,
	0x3c, 0x52, 0x9b, 0x78, 0x98, 0x7c, 0x9f, 0x03, 0x78, 0xc0, 0x3a, 0x2a, 0x37, 0xd9, 0x25, 0xbb,
	0x03, 0x05, 0x55, 0x80, 0x9c, 0x1a, 0x8e, 0x2a, 0x6e, 0xf8, 0x15, 0x62, 0xa8, 0xaf, 0x10, 0xe3,
	0x1e, 0x25, 0xbe, 0x92, 0xbf, 0x32, 0xd7, 0xef, 0xc3, 0x7b, 0xaa, 0x82, 0x29, 0x3d, 0xce, 0x4f,
	0xa0, 0x7f, 0x31, 0x76, 0x51, 0xfb, 0xfa, 0x5d, 0xb8, 0x30, 0x20, 0xbe, 0x9f, 0x4a, 0x41, 0x7e,
	0x02, 0xc6, 0x8a, 0xb4, 0x8f, 0x00, 0xae, 0x00, 0x10, 0x66, 0x89, 0x5b, 0xd3, 0x40, 0xd4, 0x65,
	0xc9, 0x2c, 0x12, 0x76, 0x28, 0x37, 0x6a, 0xbb, 0xa0, 0x27, 0x69, 0x88, 0xc5, 0x7e, 0x05, 0x20,
	0x92, 0x5f, 0x9c, 0x91, 0xa2, 0xda, 0x69, 0x39, 0xb5, 0xa7, 0x9a, 0x98, 0xc4, 0xb1, 0x17, 0x0f,
	0x4e, 0xb2, 0x33, 0x38, 0x8a, 0x95, 0x3b, 0x85, 0xf5, 0x8e, 0xf2, 0xa4, 0xde, 0x8d, 0x34, 0xa3,
	0xb8, 0xd4, 0xbf, 0x6a, 0xa2, 0x41, 0xef, 0xb9, 0x88, 0x78, 0x42, 0x75, 0xd9, 0x5c, 0x37, 0x60,
	0x51, 0x34, 0x47, 0x4c, 0xb4, 0x10, 0x2e, 0x5b, 0x4e, 0xf8, 0xce, 0x48, 0x85, 0x13, 0x47, 0x90,
	0xcb, 0x9b, 0x8b, 0x62, 0xdd, 0x72, 0xde, 0xba, 0x42, 0x4a, 0xa3, 0x09, 0xbd, 0x98, 0xf8, 0x9f,
	0x9a, 0x28, 0xce, 0x17, 0x84, 0x77, 0x1d, 0xf1, 0xc6, 0x4e, 0xd0, 0xea, 0xff, 0x92, 0x69, 0xfd,
	0x0e, 0x00, 0xa7, 0x53, 0xdf, 0xb5, 0xc8, 0x69, 0x74, 0xcf, 0x26, 0x54, 0xc6, 0x6f, 0x13, 0x4b,
	0xee, 0x3a, 0xac, 0x0c, 0xd4, 0x11, 0x4a, 0xdd, 0xad, 0x94, 0x6c, 0xb6, 0x9c, 0xda, 0x6f, 0x9a,
	0x28, 0xf3, 0x18, 0xc6, 0x99, 0x02, 0x1c, 0x43, 0xce, 0x8d, 0x23, 0xbf, 0x2b, 0x19, 0x5e, 0x83,
	0xad, 0x0c, 0x7e, 0x71, 0x55, 0x7f, 0xd4, 0xa0, 0x14, 0x4a, 0x35, 0x40, 0x83, 0x09, 0xc4, 0x33,
	0xd5, 0xf8, 0x29, 0xe8, 0xe2, 0x20, 0x08, 0xfd, 0x67, 0x60, 0x1b, 0x85, 0x8c, 0xd8, 0xae, 0xc3,
	0x5a, 0x9a, 0x49, 0x4c, 0xf1, 0x3b, 0x78, 0x5f, 0x3c, 0x83, 0x8c, 0xd3, 0x00, 0xb7, 0x7c, 0x8e,
	0x03, 0x31, 0xbc, 0x9b, 0xb6, 0x1d, 0x8e, 0x36, 0x96, 0xcd, 0xf8, 0x1e, 0x5c, 0x0c, 0xa4, 0x57,
	0x92, 0xc4, 0xdc, 0x04, 0x5a, 0xab, 0x91, 0x47, 0xc4, 0xea, 0x26, 0xdc, 0x38, 0x2b, 0x7a, 0xc4,
	0xb2, 0xf1, 0x47, 0x01, 0xe6, 0x1f, 0xb0, 0x8e, 0x6e, 0xc1, 0x62, 0xd4, 0x1a, 0x1f, 0x9c, 0xf1,
	0xe0, 0x24, 0xe3, 0xa1, 0xb2, 0x33, 0x95, 0x59, 0x2c, 0x4d, 0x1f, 0x4a, 0x23, 0x4a, 0xfb, 0x70,
	0x4a, 0x77, 0x1e, 0x9c, 0x54, 0x1a, 0xd3, 0xdb, 0xc6, 0xf1, 0xba, 0x00, 0xa9, 0x61, 0xb5, 0x7d,
	0x36, 0x42, 0x62, 0x59, 0xf9, 0x68, 0x5a, 0xcb, 0x38, 0xd2, 0x00, 0x56, 0x4f, 0x4f, 0x97, 0x09,
	0xb9, 0x39, 0x65, 0x5e, 0xf9, 0x78, 0x26, 0xf3, 0x38, 0xf0, 0x0f, 0x1a, 0xac, 0xbd, 0xb1, 0x8b,
	0x1b, 0x33, 0xe2, 0x85, 0x39, 0xfe, 0x64, 0x76, 0x9f, 0x98, 0x08, 0x86, 0x62, 0xd2, 0x89, 0xb7,
	0x26, 0x14, 0x2b, 0x32, 0xac, 0xd4, 0xa7, 0x34, 0x8c, 0xc3, 0xfc, 0xa4, 0xc1, 0x66, 0x76, 0x3f,
	0xdd, 0x39, 0x1b, 0x2e, 0xd3, 0xb1, 0x72, 0xf7, 0x9c, 0x8e, 0x11, 0xaf, 0xbd, 0xcf, 0x9e, 0xbd,
	0xaa, 0x6a, 0xcf, 0x5f, 0x55, 0xb5, 0x97, 0xaf, 0xaa, 0xda, 0xd3, 0xd7, 0xd5, 0xb9, 0xe7, 0xaf,
	0xab, 0x73, 0x7f, 0xbf, 0xae, 0xce, 0x3d, 0xde, 0x49, 0x7d, 0x61, 0xba, 0x7d, 0x6f, 0x67, 0xf4,
	0xf7, 0x90, 0x61, 0xea, 0x07, 0x9f, 0xf0, 0x63, 0xb3, 0x5d, 0x10, 0x7f, 0x2c, 0xee, 0xfe, 0x17,
	0x00, 0x00, 0xff, 0xff, 0x25, 0xbb, 0xd6, 0x61, 0x1a, 0x12, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error)
	DepositRetry(ctx context.Context, in *MsgDepositRetry, opts ...grpc.CallOption) (*MsgDepositRetryResponse, error)
	ClaimPrize(ctx context.Context, in *MsgClaimPrize, opts ...grpc.CallOption) (*MsgClaimPrizeResponse, error)
	WithdrawDeposit(ctx context.Context, in *MsgWithdrawDeposit, opts ...grpc.CallOption) (*MsgWithdrawDepositResponse, error)
	WithdrawDepositRetry(ctx context.Context, in *MsgWithdrawDepositRetry, opts ...grpc.CallOption) (*MsgWithdrawDepositRetryResponse, error)
	DrawRetry(ctx context.Context, in *MsgDrawRetry, opts ...grpc.CallOption) (*MsgDrawRetryResponse, error)
	RestoreInterchainAccounts(ctx context.Context, in *MsgRestoreInterchainAccounts, opts ...grpc.CallOption) (*MsgRestoreInterchainAccountsResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error) {
	out := new(MsgDepositResponse)
	err := c.cc.Invoke(ctx, "/lumnetwork.chain.millions.Msg/Deposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DepositRetry(ctx context.Context, in *MsgDepositRetry, opts ...grpc.CallOption) (*MsgDepositRetryResponse, error) {
	out := new(MsgDepositRetryResponse)
	err := c.cc.Invoke(ctx, "/lumnetwork.chain.millions.Msg/DepositRetry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimPrize(ctx context.Context, in *MsgClaimPrize, opts ...grpc.CallOption) (*MsgClaimPrizeResponse, error) {
	out := new(MsgClaimPrizeResponse)
	err := c.cc.Invoke(ctx, "/lumnetwork.chain.millions.Msg/ClaimPrize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) WithdrawDeposit(ctx context.Context, in *MsgWithdrawDeposit, opts ...grpc.CallOption) (*MsgWithdrawDepositResponse, error) {
	out := new(MsgWithdrawDepositResponse)
	err := c.cc.Invoke(ctx, "/lumnetwork.chain.millions.Msg/WithdrawDeposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) WithdrawDepositRetry(ctx context.Context, in *MsgWithdrawDepositRetry, opts ...grpc.CallOption) (*MsgWithdrawDepositRetryResponse, error) {
	out := new(MsgWithdrawDepositRetryResponse)
	err := c.cc.Invoke(ctx, "/lumnetwork.chain.millions.Msg/WithdrawDepositRetry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DrawRetry(ctx context.Context, in *MsgDrawRetry, opts ...grpc.CallOption) (*MsgDrawRetryResponse, error) {
	out := new(MsgDrawRetryResponse)
	err := c.cc.Invoke(ctx, "/lumnetwork.chain.millions.Msg/DrawRetry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RestoreInterchainAccounts(ctx context.Context, in *MsgRestoreInterchainAccounts, opts ...grpc.CallOption) (*MsgRestoreInterchainAccountsResponse, error) {
	out := new(MsgRestoreInterchainAccountsResponse)
	err := c.cc.Invoke(ctx, "/lumnetwork.chain.millions.Msg/RestoreInterchainAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	Deposit(context.Context, *MsgDeposit) (*MsgDepositResponse, error)
	DepositRetry(context.Context, *MsgDepositRetry) (*MsgDepositRetryResponse, error)
	ClaimPrize(context.Context, *MsgClaimPrize) (*MsgClaimPrizeResponse, error)
	WithdrawDeposit(context.Context, *MsgWithdrawDeposit) (*MsgWithdrawDepositResponse, error)
	WithdrawDepositRetry(context.Context, *MsgWithdrawDepositRetry) (*MsgWithdrawDepositRetryResponse, error)
	DrawRetry(context.Context, *MsgDrawRetry) (*MsgDrawRetryResponse, error)
	RestoreInterchainAccounts(context.Context, *MsgRestoreInterchainAccounts) (*MsgRestoreInterchainAccountsResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Deposit(ctx context.Context, req *MsgDeposit) (*MsgDepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (*UnimplementedMsgServer) DepositRetry(ctx context.Context, req *MsgDepositRetry) (*MsgDepositRetryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositRetry not implemented")
}
func (*UnimplementedMsgServer) ClaimPrize(ctx context.Context, req *MsgClaimPrize) (*MsgClaimPrizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimPrize not implemented")
}
func (*UnimplementedMsgServer) WithdrawDeposit(ctx context.Context, req *MsgWithdrawDeposit) (*MsgWithdrawDepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawDeposit not implemented")
}
func (*UnimplementedMsgServer) WithdrawDepositRetry(ctx context.Context, req *MsgWithdrawDepositRetry) (*MsgWithdrawDepositRetryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawDepositRetry not implemented")
}
func (*UnimplementedMsgServer) DrawRetry(ctx context.Context, req *MsgDrawRetry) (*MsgDrawRetryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DrawRetry not implemented")
}
func (*UnimplementedMsgServer) RestoreInterchainAccounts(ctx context.Context, req *MsgRestoreInterchainAccounts) (*MsgRestoreInterchainAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreInterchainAccounts not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumnetwork.chain.millions.Msg/Deposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Deposit(ctx, req.(*MsgDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DepositRetry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDepositRetry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DepositRetry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumnetwork.chain.millions.Msg/DepositRetry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DepositRetry(ctx, req.(*MsgDepositRetry))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimPrize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimPrize)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimPrize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumnetwork.chain.millions.Msg/ClaimPrize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimPrize(ctx, req.(*MsgClaimPrize))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_WithdrawDeposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWithdrawDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).WithdrawDeposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumnetwork.chain.millions.Msg/WithdrawDeposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).WithdrawDeposit(ctx, req.(*MsgWithdrawDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_WithdrawDepositRetry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWithdrawDepositRetry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).WithdrawDepositRetry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumnetwork.chain.millions.Msg/WithdrawDepositRetry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).WithdrawDepositRetry(ctx, req.(*MsgWithdrawDepositRetry))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DrawRetry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDrawRetry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DrawRetry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumnetwork.chain.millions.Msg/DrawRetry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DrawRetry(ctx, req.(*MsgDrawRetry))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RestoreInterchainAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRestoreInterchainAccounts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RestoreInterchainAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lumnetwork.chain.millions.Msg/RestoreInterchainAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RestoreInterchainAccounts(ctx, req.(*MsgRestoreInterchainAccounts))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lumnetwork.chain.millions.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deposit",
			Handler:    _Msg_Deposit_Handler,
		},
		{
			MethodName: "DepositRetry",
			Handler:    _Msg_DepositRetry_Handler,
		},
		{
			MethodName: "ClaimPrize",
			Handler:    _Msg_ClaimPrize_Handler,
		},
		{
			MethodName: "WithdrawDeposit",
			Handler:    _Msg_WithdrawDeposit_Handler,
		},
		{
			MethodName: "WithdrawDepositRetry",
			Handler:    _Msg_WithdrawDepositRetry_Handler,
		},
		{
			MethodName: "DrawRetry",
			Handler:    _Msg_DrawRetry_Handler,
		},
		{
			MethodName: "RestoreInterchainAccounts",
			Handler:    _Msg_RestoreInterchainAccounts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lumnetwork/chain/millions/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdaterAddress) > 0 {
		i -= len(m.UpdaterAddress)
		copy(dAtA[i:], m.UpdaterAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.UpdaterAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if m.MinDepositDrawDelta != nil {
		n1, err1 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.MinDepositDrawDelta, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MinDepositDrawDelta):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintTx(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x42
	}
	if m.FeesStakers != nil {
		{
			size := m.FeesStakers.Size()
			i -= size
			if _, err := m.FeesStakers.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.PrizeExpirationDelta != nil {
		n2, err2 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.PrizeExpirationDelta, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.PrizeExpirationDelta):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintTx(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x32
	}
	if m.MaxDrawScheduleDelta != nil {
		n3, err3 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.MaxDrawScheduleDelta, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MaxDrawScheduleDelta):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintTx(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x2a
	}
	if m.MinDrawScheduleDelta != nil {
		n4, err4 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.MinDrawScheduleDelta, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MinDrawScheduleDelta):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintTx(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x22
	}
	if m.MaxPrizeBatchQuantity != nil {
		{
			size := m.MaxPrizeBatchQuantity.Size()
			i -= size
			if _, err := m.MaxPrizeBatchQuantity.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MaxPrizeStrategyBatches != nil {
		{
			size := m.MaxPrizeStrategyBatches.Size()
			i -= size
			if _, err := m.MaxPrizeStrategyBatches.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MinDepositAmount != nil {
		{
			size := m.MinDepositAmount.Size()
			i -= size
			if _, err := m.MinDepositAmount.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRegisterPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CreatorAddress) > 0 {
		i -= len(m.CreatorAddress)
		copy(dAtA[i:], m.CreatorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CreatorAddress)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Bech32PrefixValAddr) > 0 {
		i -= len(m.Bech32PrefixValAddr)
		copy(dAtA[i:], m.Bech32PrefixValAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Bech32PrefixValAddr)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Bech32PrefixAccAddr) > 0 {
		i -= len(m.Bech32PrefixAccAddr)
		copy(dAtA[i:], m.Bech32PrefixAccAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Bech32PrefixAccAddr)))
		i--
		dAtA[i] = 0x4a
	}
	{
		size, err := m.PrizeStrategy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.DrawSchedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.MinDepositAmount.Size()
		i -= size
		if _, err := m.MinDepositAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Validators[iNdEx])
			copy(dAtA[i:], m.Validators[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Validators[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ConnectionId) > 0 {
		i -= len(m.ConnectionId)
		copy(dAtA[i:], m.ConnectionId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ConnectionId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NativeDenom) > 0 {
		i -= len(m.NativeDenom)
		copy(dAtA[i:], m.NativeDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NativeDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdatePool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdatePool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdatePool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdaterAddress) > 0 {
		i -= len(m.UpdaterAddress)
		copy(dAtA[i:], m.UpdaterAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.UpdaterAddress)))
		i--
		dAtA[i] = 0x32
	}
	if m.PrizeStrategy != nil {
		{
			size, err := m.PrizeStrategy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DrawSchedule != nil {
		{
			size, err := m.DrawSchedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MinDepositAmount != nil {
		{
			size := m.MinDepositAmount.Size()
			i -= size
			if _, err := m.MinDepositAmount.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Validators[iNdEx])
			copy(dAtA[i:], m.Validators[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Validators[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdatePoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdatePoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdatePoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsSponsor {
		i--
		if m.IsSponsor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.WinnerAddress) > 0 {
		i -= len(m.WinnerAddress)
		copy(dAtA[i:], m.WinnerAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.WinnerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DepositorAddress) > 0 {
		i -= len(m.DepositorAddress)
		copy(dAtA[i:], m.DepositorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DepositorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DepositId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DepositId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositRetry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositRetry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DepositorAddress) > 0 {
		i -= len(m.DepositorAddress)
		copy(dAtA[i:], m.DepositorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DepositorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DepositId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DepositId))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgDepositRetryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDepositRetryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDepositRetryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgClaimPrize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimPrize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimPrize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WinnerAddress) > 0 {
		i -= len(m.WinnerAddress)
		copy(dAtA[i:], m.WinnerAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.WinnerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if m.PrizeId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PrizeId))
		i--
		dAtA[i] = 0x18
	}
	if m.DrawId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DrawId))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimPrizeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimPrizeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimPrizeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ToAddress) > 0 {
		i -= len(m.ToAddress)
		copy(dAtA[i:], m.ToAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ToAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DepositorAddress) > 0 {
		i -= len(m.DepositorAddress)
		copy(dAtA[i:], m.DepositorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DepositorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DepositId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DepositId))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawDepositResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawDepositResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawDepositResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithdrawalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.WithdrawalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawDepositRetry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawDepositRetry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawDepositRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DepositorAddress) > 0 {
		i -= len(m.DepositorAddress)
		copy(dAtA[i:], m.DepositorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DepositorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.WithdrawalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.WithdrawalId))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawDepositRetryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawDepositRetryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawDepositRetryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDrawRetry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDrawRetry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDrawRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DrawRetryAddress) > 0 {
		i -= len(m.DrawRetryAddress)
		copy(dAtA[i:], m.DrawRetryAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DrawRetryAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DrawId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DrawId))
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgDrawRetryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDrawRetryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDrawRetryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRestoreInterchainAccounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRestoreInterchainAccounts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRestoreInterchainAccounts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RestorerAddress) > 0 {
		i -= len(m.RestorerAddress)
		copy(dAtA[i:], m.RestorerAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RestorerAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRestoreInterchainAccountsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRestoreInterchainAccountsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRestoreInterchainAccountsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinDepositAmount != nil {
		l = m.MinDepositAmount.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MaxPrizeStrategyBatches != nil {
		l = m.MaxPrizeStrategyBatches.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MaxPrizeBatchQuantity != nil {
		l = m.MaxPrizeBatchQuantity.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinDrawScheduleDelta != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MinDrawScheduleDelta)
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MaxDrawScheduleDelta != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MaxDrawScheduleDelta)
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PrizeExpirationDelta != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.PrizeExpirationDelta)
		n += 1 + l + sovTx(uint64(l))
	}
	if m.FeesStakers != nil {
		l = m.FeesStakers.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinDepositDrawDelta != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MinDepositDrawDelta)
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.UpdaterAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRegisterPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NativeDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ConnectionId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Validators) > 0 {
		for _, s := range m.Validators {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = m.MinDepositAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.DrawSchedule.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.PrizeStrategy.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Bech32PrefixAccAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Bech32PrefixValAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CreatorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRegisterPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	return n
}

func (m *MsgUpdatePool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	if len(m.Validators) > 0 {
		for _, s := range m.Validators {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.MinDepositAmount != nil {
		l = m.MinDepositAmount.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DrawSchedule != nil {
		l = m.DrawSchedule.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PrizeStrategy != nil {
		l = m.PrizeStrategy.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.UpdaterAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdatePoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.DepositorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.WinnerAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.IsSponsor {
		n += 2
	}
	return n
}

func (m *MsgDepositResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DepositId != 0 {
		n += 1 + sovTx(uint64(m.DepositId))
	}
	return n
}

func (m *MsgDepositRetry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	if m.DepositId != 0 {
		n += 1 + sovTx(uint64(m.DepositId))
	}
	l = len(m.DepositorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDepositRetryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgClaimPrize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	if m.DrawId != 0 {
		n += 1 + sovTx(uint64(m.DrawId))
	}
	if m.PrizeId != 0 {
		n += 1 + sovTx(uint64(m.PrizeId))
	}
	l = len(m.WinnerAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimPrizeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgWithdrawDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	if m.DepositId != 0 {
		n += 1 + sovTx(uint64(m.DepositId))
	}
	l = len(m.DepositorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgWithdrawDepositResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithdrawalId != 0 {
		n += 1 + sovTx(uint64(m.WithdrawalId))
	}
	return n
}

func (m *MsgWithdrawDepositRetry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	if m.WithdrawalId != 0 {
		n += 1 + sovTx(uint64(m.WithdrawalId))
	}
	l = len(m.DepositorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgWithdrawDepositRetryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDrawRetry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	if m.DrawId != 0 {
		n += 1 + sovTx(uint64(m.DrawId))
	}
	l = len(m.DrawRetryAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDrawRetryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRestoreInterchainAccounts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	l = len(m.RestorerAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRestoreInterchainAccountsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDepositAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MinDepositAmount = &v
			if err := m.MinDepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPrizeStrategyBatches", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxPrizeStrategyBatches = &v
			if err := m.MaxPrizeStrategyBatches.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPrizeBatchQuantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxPrizeBatchQuantity = &v
			if err := m.MaxPrizeBatchQuantity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDrawScheduleDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinDrawScheduleDelta == nil {
				m.MinDrawScheduleDelta = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.MinDrawScheduleDelta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDrawScheduleDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxDrawScheduleDelta == nil {
				m.MaxDrawScheduleDelta = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.MaxDrawScheduleDelta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrizeExpirationDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrizeExpirationDelta == nil {
				m.PrizeExpirationDelta = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.PrizeExpirationDelta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeesStakers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.FeesStakers = &v
			if err := m.FeesStakers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDepositDrawDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinDepositDrawDelta == nil {
				m.MinDepositDrawDelta = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.MinDepositDrawDelta, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdaterAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdaterAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NativeDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDepositAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinDepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawSchedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DrawSchedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrizeStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrizeStrategy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32PrefixAccAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32PrefixAccAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32PrefixValAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32PrefixValAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdatePool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdatePool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdatePool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDepositAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MinDepositAmount = &v
			if err := m.MinDepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawSchedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DrawSchedule == nil {
				m.DrawSchedule = &DrawSchedule{}
			}
			if err := m.DrawSchedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrizeStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrizeStrategy == nil {
				m.PrizeStrategy = &PrizeStrategy{}
			}
			if err := m.PrizeStrategy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdaterAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdaterAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdatePoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdatePoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdatePoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinnerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WinnerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSponsor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSponsor = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositId", wireType)
			}
			m.DepositId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepositId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositRetry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositRetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositRetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositId", wireType)
			}
			m.DepositId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepositId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDepositRetryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDepositRetryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDepositRetryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimPrize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimPrize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimPrize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawId", wireType)
			}
			m.DrawId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrawId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrizeId", wireType)
			}
			m.PrizeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrizeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinnerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WinnerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimPrizeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimPrizeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimPrizeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositId", wireType)
			}
			m.DepositId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepositId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawDepositResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawDepositResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawDepositResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalId", wireType)
			}
			m.WithdrawalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithdrawalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawDepositRetry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawDepositRetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawDepositRetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawalId", wireType)
			}
			m.WithdrawalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithdrawalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawDepositRetryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawDepositRetryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawDepositRetryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDrawRetry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDrawRetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDrawRetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawId", wireType)
			}
			m.DrawId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrawId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawRetryAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrawRetryAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDrawRetryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDrawRetryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDrawRetryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRestoreInterchainAccounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRestoreInterchainAccounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRestoreInterchainAccounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestorerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RestorerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRestoreInterchainAccountsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRestoreInterchainAccountsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRestoreInterchainAccountsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
